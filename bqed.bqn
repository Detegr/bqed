While â† {ğ•©{ğ”½âŸğ”¾âˆ˜ğ”½_ğ•£_ğ”¾âˆ˜ğ”½âŸğ”¾ğ•©}ğ•¨@}Â´

# Fetch terminal width and height using `tput`
# Evaluate with â€¢BQN to convert strings to integers
wâ†â€¢BQN 1âŠ‘â€¢SH "tput"â€¿"cols"
hâ†â€¢BQN 1âŠ‘â€¢SH "tput"â€¿"lines"

# Open file contents
f â† âŸ¨""âŸ©

# Reshape file contents into a screen size matrix
Scrn â† âˆ˜â€¿wâŠ¸â¥ŠÂ·âˆ¾wâŠ¸â†‘Â¨

# ANSI escape code
ansiesc â† @+27
enter â† @+13
c_q â† @+17
tab â† @+9
backspace â† @+127

# Current cursor position
âŸ¨cx, cyâŸ© â† 1â€¿1

# Laminate array of strings with ANSI escape and concatenate them together
Ansi â† âˆ¾ansiescâŠ¸âˆ¾âŒœ

# Create a new line: update cursor and add line to `f`
NewLine â† {ğ•Š: cxâ†©1 â‹„ cyâ†©(h-1)âŒŠcy+1 â‹„ fâ†©fâˆ¾<""}

# Move cursor to a specific position
CursorTo â† â€¢OutRawâˆ˜(ansiescâˆ¾"["âˆ¾(â€¢Fmt 1âŠ¸âŠ‘)âˆ¾";"âˆ¾(â€¢Fmt âŠ‘)âˆ¾"H"âˆ˜âŠ¢)

# Insert character (right argument) to left argument at position `cx`
InsertChar â† {ğ•¨ğ•Šğ•©: ((cx-1)â†‘ğ•¨)âˆ¾ğ•©âˆ¾((cx-1)â†“ğ•¨)}

# Put character to screen, update cursor
PutChar â† {ğ•Šğ•©: fâ†©ğ•©{InsertCharâŸœğ•¨âŒ¾((cy-1)âŠ¸âŠ‘)ğ•©}f â‹„ cxâ†©cx+1}

DrawEditor â† {ğ•Šğ•©: CursorTo 1â€¿1 â‹„ â€¢OutRawÂ¨ğ•© â‹„ CursorTo cxâ€¿cy}

# Restore terminal state and exit
Quit â† {â€¢SH "stty"â€¿"-raw"â€¿"echo" â‹„ â€¢Exit ğ•©}

PutTab â† {ğ•Š: PutChar "        " â‹„ cxâ†©cx+7 }

PutBackspace â† {ğ•Š:
  # Current line index
  ci â† cy-1
  # Current line
  cl â† (cy-1)âŠ‘f
  {ğ•Š:
    # Index where to delete. Complex because if we're on the first column,
    # we need to use a high value to produce a mask that does not delete anything
    i â† {1+â‰ cl}âŸ{(cx-1)â‰¤0} cx-2
    # Boolean mask that has the current character as 0 and everything else as 1
    # TODO: There most likely exists a better way to do this. This is way too complex.
    m â† i{Â¬Â»âŸğ•¨ 1âˆ¾(1-Ëœğ•©)â¥Š0}â‰ cl
    # Filter out the corresponding line in `f`
    f â†© mâŠ¸/âŒ¾(ciâŠ¸âŠ‘)f
    # Update cursor
    cx â†© (cx-1)âŒˆ1
  }âŸ(0<â‰ cl) @ # Do above only if the line has content

  # TODO: For the future: should wrap to a previous line if we're at the beginning of the line.
  #                       should remove an empty line if we're at the beginning of the line.
}

HandleEsc â† {
  "[": HandleEsc â€¢GetChar @ ;
  # Cursor movement
  "A": cy â†© (cy-1)âŒˆ1  â‹„ cx â†© cxâŒŠ1+â‰ fâŠ‘Ëœ(cy-1) ; # Up
  "B": cy â†© (cy+1)âŒŠâ‰ f â‹„ cx â†© cxâŒŠ1+â‰ fâŠ‘Ëœ(cy-1) ; # Down
  "C": cx â†© (cx+1)âŒŠ1+â‰ fâŠ‘Ëœcy-1                ; # Right
  "D": cx â†© (cx-1)âŒˆ1                         ; # Left
  ğ•©: PutChar â€¢Fmt (âŠ‘ğ•©-@)
}

Esc â† {ğ•Š: HandleEsc â€¢GetChar @ }

# Special keycodes to react to
keys â† ansiescâ€¿c_qâ€¿tabâ€¿backspaceâ€¿enter

# List of functions corresponding indices of `keys`
kfns â† Escâ€¿Quitâ€¿PutTabâ€¿PutBackspaceâ€¿NewLineâ€¿PutChar

# Get function for keycode
Kfn â† âŠ‘keysâŠ¸âŠ

# Status bar contents
StatusStr â† {ğ•Š:
  style â† ansiescâˆ¾"[100;37m"
  s â† "<" âˆ¾ (â€¢Fmt cx) âˆ¾ "," âˆ¾ (â€¢Fmt cy) âˆ¾ ">" âˆ¾ " | <C-q> to exit"
  pad â† (w-â‰ s)/" "
  styleâˆ¾sâˆ¾padâˆ¾ansiescâˆ¾"[0m"
}

DrawStatus â† {ğ•Š: CursorTo 1â€¿h â‹„ â€¢OutRaw StatusStr @ â‹„ CursorTo cxâ€¿cy}

# Put terminal to raw mode, disable echo
â€¢SH "stty"â€¿"raw"â€¿"-echo"

# Clear screen and position cursor to top
â€¢OutRaw Ansi "[2J"â€¿"[H"

While 1â€¿{ğ•¤
  DrawEditor (Scrn f)
  DrawStatus @

  # Get a character and run a function for the input
  Kfnâ—¶kfns â€¢GetChar @
}
